---
layout: post
title: "A scalable development process - Part 1"
description: "A scalable development process - Part 1"
comments: true
keywords: "devcongress, tech, meetup, scaling, scalable development process"
published: false
---

Every so often, as app developers when we build apps, one question we constant try to answer is how will the app scale.  This lead us to take some steps and measures to optimize our apps in the hope that when we get 5000 user on launch day, our severs dont go down. Unless you operate at the scale of Google of Facebook, you will not get  5,000 user on launch day. So if you build to handle traffic from 5,000 people, or 5,000 request per second it becomes premature optimisation. And in the words of Donald Knuth himself,   [premature optimization? It is the root of all evil.](https://en.wikiquote.org/wiki/Donald_Knuth)

One thing programmers often over look is how well their development process scales over time. I think rather than write you apps that scale from the get go, you should create a development process that scales from the get go. And here is why i think so. Through out the life of an existing applications, developers will make decission based on choices presented with a singular context in mind. The choices made with context in mind  will lead down a particular development path that becomes a part of "the architecture". As wonderful as the human brain is, one thing is for sure, you can not an will not recollect every single details that went into the making of a particular decission. The reason for some decision transcends code. When your development process help convey the most important of these reasons in a way that makes it easy to comback to, pick up and continue, it relieves developers of the cognitive load in thinking through various decisions as you go along. The weight of this congnitive load breeds anxiety and anxiety begets decsions made without confidence, and that is when people start to feel like shit. They start enjoying the whole development experience less and bad decisions made result in the increase of general technical debt. 

This way of development is also way more expensive. When people feel like shit at their jobs they leave. When people leave you loose a chunk of time in going through the hiring process. Getting new people up to speed on a current project is a very expensive process, especially if a current process has knowledge gaps. New hires will have to constantly ask questions and depending on the number of questions they have and how early they get answered, it is all time ataken away from how early they can get productive. When you create a development process that scales, all things sort of fall in place and in the long term, it becomes very easy to optimize your app to scale as time goes on. It also way less expensive in terms of resources including development time, down time and time spent hiring new people. All of this translate to money for a business, but most importantly, people are happy at the work because the will enjoy it.

So what do i mean by creating a development process that scales.

Before i go on to explain what i mean by a development process that scales, I want to establish a few things. First and formost, the main focus of this series of post is to inform and advise on what to do at the early stage of your development cycle. From starting the project to just before there is more than 1 person working on it. That is not to say this cannot be applied to you if you have already started a project. You should bare in mind that, as time goes on. It because more expensive and difficult to change course, and cost is one of the things that should be balanced with all if this changes beacuase it can and might ultimately be the death of a business. But if you think you can absorb the cost of the change in your existing process, you are most welcome to do so. All the comments and advices in this post should be taken with your specific context in consideration because context is a huge factor in what makes the same decision right or wrong for 2 similar use cases. 

Now lets talk about what i mean by creating a development process that scales. 

When you build version 1 of your app to handle 5000 request per second, that is not what i term a scallable develpment process. Here are a few characteristics of a development process that scales. How these characteristics apply to your project signifies how scallable your development process is. I dont view scallability of the development process as a binary parameter. You do or do not have a scallable development process. I view the scalability of you process as a spectrum when your try to optimize your process to increase the scalability parameter. 

1. When new team members are added to the project, the where to find resources, how to change resources and what resources are doing is easy. The time it takes for new team members to start making meaningful contributions to the whole project remains inversly proportional to the scalability of your development process. Because developers are expensive and the less time they spend understanding the system, the earlier you can get your monies worth. Yes, there are systems so huge that it takes months to understand the whole thing before you can make a contribution. But that is outside the scope of this post. 
2. The next major telling factor in how scallable your process is how easily you can refactor and deploy changes without worry about issues that regress. Is your confidence level in how well the changes stick high enough that you can deploy on a friday night? This is what i call the friday deploy confidence factor. If the last thing you do on a friday before you go out for drinks with friends on a friday is deployment of a new feature, How convidence are you that it will stick. The anxiety deployments come with is bad enough, and to deploy on a friday makes is worse enough. No matter how high your friday deploy confidence is, please dont deploy on a friday. Go out, have some drinks and enjoy life. 
3. Another telling factor which determines how scallable your process is how easily you can swith out a component of your app and replace it with equivalient systems and trust that it will all come together nicely. A typical example is payments. If your business lead should succeed in negotiating better payment terms with a deifferent payment partner, how easily and early can you switch to the new systems, knowing very well, the apis will be different. The way you answer this tells alot about how your entire sytem comes together. Other components that you should be able to switch out include, loggers, caching layers amongs a few. 
4. If you have a very scalable development process, one thing that tells is how much confidence you have in letting juniors contribute to and entire system knowing that you have processes in place to catch them when they messup. Juniors messup up. It is the God given right to. It is the only way they will learn. For a lot of people without a scallable development process, they give juniors mundane tasks to perform and slowly watch as they work to know exactly how ready they are to do the big stuff. If you have to watch them perform before you give them meaningful tasks, you are most likely doing something wrong. This is because you watch them because you are sure if they goof up, your systems, will most likely come crushing. and the trust element is put in the human beings. But humans err, and if you dont have  checks to catch potential errs, some one will most likely err and more often more than once. 
5. As fallible creatures, we will most definitely err. And when we do, how early we are in noticing, replicating, understanding, fixing and deploying patches is a key factor in how our development process scales. If a single request crashes your app, does the whole system come down with it? Do you have sytems in place that notify you of crashes before users call you to tell you your app is crushing? In this particular case being proactive about it prevents being caught by surprise and having to drop all you are doing unexpectedly. Also the longer you stay down, the more money you loose. 

This list is by no means exhaustive, but one idea I am trying to put across is that, your whole process should be one of proactiveness rather than being a reactive one. Being proactive gives you the advantage of planning out how you approach issues. Unlike when you are reactive, where you do things base on issues that spring up. When you are proactive, you are easily able to determine cost for each process, and execute in a manner that makes in most importantly enjoyable. 

Esentially this is a series on things that reduce the cognitive load on developers, that way they have increased confidence in what they are working on and can develiver faster. In the end you should emply any stategies that go to alliviate the cognitive load on you developers. 

Now that we know what it means to have a development process that scales, We can talk about some statgies you can use to increase the scalability of your development process in no particular order. 

